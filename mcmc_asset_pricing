# Julia packages
using Revise;
using StatsPlots;
using Distributions;
using Statistics;
using StatsBase;
using Random;
using RCall;
@rimport ks as rks;

# set seed
Random.seed!(1234);

# problem set up 
lambda = 0.85;
a = 0.05;
b = 0.9;
varK = 100;
# define kernel and forcing
function K(x, y)
    d0 = Normal(a*x + b, sqrt(varK))
    truncated_d0 = truncated(d0, 0, 1)
    return(pdf.(truncated_d0, y))
end
phi(x) = (exp(x^2)-1) * (x <= 1) * (x >= 0);
phi_gradient(x) = 2*x*exp(x^2) * (x <= 1) * (x >= 0);



function mcmc_weights(k, x)
    weight = phi(x[k]);
    for i=2:k
        weight = weight * (lambda*pdf(Normal(a*x[i-1] + b, sqrt(varK)), x[i])/ 
        cdf(Normal(0, 1), (1-a*x[i-1]-b)/sqrt(varK))-cdf(Normal(0, 1), (-a*x[i-1]-b)/sqrt(varK))
        );
    end
    return weight
end

N = 100;
k = zeros(N, 1);
k[1] = 1;
X = [1];

pb = 1/3;
pd = 1/3;

for n=2:N
    Pb = pb;
    if(k[n-1] > 1)
        Pd = pd;
    else
        Pd = 0;
    end
    u = rand(1)[1];
    if(u < Pb) 
        # Birth move
        k[n] = k[n-1] + 1;
        Intk = Int(k[n]);
        j = sample(1:k[n], Weights(1/k[n]*ones(Intk)), Intk);
        push!(X, [X[n-1][1:(j-1)], rand(1), X[n-1][j:k[n-1]]]);
    elseif (u < Pb+Pd)
        # Death move
        k[n] = k[n-1] - 1;
        Intk = Int(k[n-1]);
        j = sample(1:k[n-1], Weights(1/k[n-1]*ones(Intk), Intk));
        push!(X, [X[n-1][1:(j-1)], rand(1), X[n-1][(j+1):k[n-1]]]);
    else
        # Update move
        k[n] = k[n-1];
        Intk = Int(k[n]);
        j = Int(sample(1:k[n], Weights(1/k[n]*ones(Intk)), Intk));
        push!(X, [X[n-1][1:(j-1)], rand(1), X[n-1][(j+1):k[n-1]]]);
    end
    weight =  mcmc_weights(k[n], X[n])/mcmc_weights(k[n-1],X[n-1]);
end